# -*- coding: utf-8 -*-
"""123190059_NguyenQuocBao.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PGVHQkdI0inskR3C4rs2lzf1unLfmKr1
"""

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import numpy as np
import matplotlib.pyplot as plt
import math as m
from scipy.io.wavfile import read,write
from IPython.display import Audio
from numpy.fft import fft,ifft

#Hàm tính STE:
#Tham số đầu vào: list đã được phân khung
#tính toán STE theo công thức đã học
#Giá trị trả về: một lits có số lượng phần tử là số khung và
#mỗi phần tử là một giá trị STE của khung tương ứng
def STE(array):
    temp=np.zeros(len(array))
    for i in range(len(array)):
        for j in range(len(array[i])):
            temp[i]=temp[i]+array[i][j]**2
        temp[i]=temp[i]/len(array[i])
    return temp
#-----------------------------------------------------------
#Hàm tính ZCR:
#Tham số đầu vào: list đã được phân khung
#tính toán ZCR theo công thức đã học
#Giá trị trả về: một lits có số lượng phần tử là số khung và
#mỗi phần tử là một giá trị ZCR của khung tương ứng
def ZCR (array):
    temp=np.zeros(len(array))
    for i in range(len(array)):
        for j in range(len(array[i])-1):
            if(np.sign(array[i][j])*np.sign(array[i][j+1])<0):
                temp[i]=temp[i]+1
        temp[i]=temp[i]/len(array[i])
    return temp
#-----------------------------------------------------------
#Hàm chuẩn hóa:
#Tham số đầu vào: list (mảng) 1 chiều (X)
#Tính toán theo công thức X[i]=(X[i]-min(X))/(max(X)-min(X))
#Giá trị trả về: list mới với các giá trị chạy từ 0 tới 1
def norm(array):
    minarr=np.min(array)
    maxarr=np.max(array)
    marr=maxarr-minarr
    for i in range(len(array)):
        array[i]=(array[i]-minarr)/marr
    return array
#-----------------------------------------------------------
#Hàm kết hợp STE và ZCR:
#Tham số đầu vào: 2 list lần lượt sẽ là STE và ZCR
#Lấy STE-ZCR theo từng phần tử
#Giá trị trả về: list mới là hàm kết hợp cần tính
def ens(array1, array2):
    temp=np.zeros(len(array1))
    for i in range(len(array1)):
        temp[i]=array1[i]-array2[i]
        
    return temp
#-----------------------------------------------------------
#Hàm tìm các vạch phân đoạn:
#Tham số đầu vào: list là hàm kết hợp, moc là giá trị ngưỡng (threshold)
#Ở các vị trí hàm kết hợp trên băng qua ngưỡng, lưu lại chỉ số của list+1
#Đây chính là vạch phân đoạn cần tìm
def discriminate(array, moc):
    temp=[]
    x=0
    for i in range(len(array)-1):
        if(array[i]>moc>array[i+1] or array[i]<moc<array[i+1]):
            temp.append(i+1)
    return temp
#------------------------------------------------------------

fs1, data1=read('phone_F2.wav')
fs2, data2=read('phone_M2.wav')
fs3, data3=read('studio_F2.wav')
fs4, data4=read('studio_M2.wav')

data1=data1/32768.0
data2=data2/32768.0
data3=data3/32768.0
data4=data4/32768.0
l1=len(data1)
l2=len(data2)
l3=len(data3)
l4=len(data4)
#---------------------------
#tính toán độ dài khung
tframe=0.02 # 20ms
lframe1=tframe*fs1 # length of a frame in samples
lframe2=tframe*fs2
lframe3=tframe*fs3
lframe4=tframe*fs4
#---------------------------

# np.array_split(a, b):
# chia mảng a thành các mảng con bằng nhau, mỗi mảng con có b phần tử
X1=np.array_split(data1, l1/lframe1)
X2=np.array_split(data2, l2/lframe2)
X3=np.array_split(data3, l3/lframe3)
X4=np.array_split(data4, l4/lframe4)
#---------------------------

#Tính hàm năng lượng ngắn hạn (STE)
ste1=STE(X1)
ste2=STE(X2)
ste3=STE(X3)
ste4=STE(X4)
#Tính tốc độ băng qua 0
zcr1=ZCR(X1)
zcr2=ZCR(X2)
zcr3=ZCR(X3)
zcr4=ZCR(X4)
#---------------------------

#Chuẩn hóa các hàm thuộc tính
ste1=np.where(ste1>0.000000001, ste1, 10**-7)
ste1=norm(np.log(ste1))
zcr1=norm(zcr1)

ste2=np.where(ste2>0.000000001, ste2, 10**-7)
ste2=norm(np.log(ste2))
zcr2=norm(zcr2)

ste3=np.where(ste3>0.000000001, ste3, 10**-7)
ste3=norm(np.log(ste3))
zcr3=norm(zcr3)

ste4=np.where(ste4>0.000000001, ste4, 10**-7)
ste4=norm(np.log(ste4))
zcr4=norm(zcr4)
#---------------------------

#Hàm kết hợp STE và ZCR:
W1=ens(ste1, zcr1)
W2=ens(ste2, zcr2)
W3=ens(ste3, zcr3)
W4=ens(ste4, zcr4)
#Chuẩn hóa hàm tính được
W1=norm(W1)
W2=norm(W2)
W3=norm(W3)
W4=norm(W4)
#--------------------------

threshold=0.58

vert1=discriminate(W1, threshold)
vert2=discriminate(W2, threshold)
vert3=discriminate(W3, threshold)
vert4=discriminate(W4, threshold)

bienc1=[51, 94, 98, 108, 113, 130, 138, 167, 169, 173, 181, 190, 196, 200, 240]

fig, ax1=plt.subplots(figsize=(15, 5))
	# lệnh dưới cho phép trục y của ax2, ax3, ax4 đè lên ax1
ax2=ax1.twiny()
ax3=ax1.twiny()
ax3=ax1.twinx()
ax4=ax1.twiny()
ax4=ax1.twinx()
mask=np.zeros(len(ste1))
line1=ax1.plot(mask, linestyle='-', color='y', alpha=0)
line2=ax2.plot(data1, label="phone_F2", alpha=1)
ax2.get_xaxis().set_visible(False)
line3=ax3.vlines(x=vert1, label="bien tinh toan", ymin=-1, ymax=1, color='r', linewidth=1)
ax3.get_xaxis().set_visible(False)
ax3.get_yaxis().set_visible(False)
line4=ax4.vlines(x=bienc1, label="bien chuan", ymin=-1, ymax=1, color='g', linewidth=1, linestyle='-.')
ax4.get_xaxis().set_visible(False)
ax4.get_yaxis().set_visible(False)
fig.legend()
plt.title("phone_F2")

print(vert1)

bienc2=[27, 53, 56, 62, 66, 73, 84, 99, 103, 106, 109, 115, 122, 125]

fig, ax1=plt.subplots(figsize=(15, 5))
	# lệnh dưới cho phép trục y của ax2, ax3, ax4 đè lên ax1
ax2=ax1.twiny()
ax3=ax1.twiny()
ax3=ax1.twinx()
ax4=ax1.twiny()
ax4=ax1.twinx()
mask=np.zeros(len(ste2))
line1=ax1.plot(mask, linestyle='-', color='r', alpha=0)
line2=ax2.plot(data2, label="phone_M2", alpha=1)
ax2.get_xaxis().set_visible(False)
line3=ax3.vlines(x=vert2, label="bien tinh toan", ymin=-1, ymax=1, color='r', linewidth=1)
ax3.get_xaxis().set_visible(False)
ax3.get_yaxis().set_visible(False)
line4=ax4.vlines(x=bienc2, label="bien chuan", ymin=-1, ymax=1, color='g', linewidth=1, linestyle='-.')
ax4.get_xaxis().set_visible(False)
ax4.get_yaxis().set_visible(False)
fig.legend()
plt.title("phone_M2")

print(vert2)

bienc3=[30, 63, 64, 68, 71, 88, 92, 99, 103, 119, 157]

fig, ax1=plt.subplots(figsize=(15, 5))
	# lệnh dưới cho phép trục y của ax2, ax3, ax4 đè lên ax1
ax2=ax1.twiny()
ax3=ax1.twiny()
ax3=ax1.twinx()
ax4=ax1.twiny()
ax4=ax1.twinx()
mask=np.zeros(len(ste3))
line1=ax1.plot(mask, linestyle='-', color='r', alpha=0)
line2=ax2.plot(data3, label="studio_F2", alpha=1)
ax2.get_xaxis().set_visible(False)
line3=ax3.vlines(x=vert3, label="bien tinh toan", ymin=-1, ymax=1, color='r', linewidth=1)
ax3.get_xaxis().set_visible(False)
ax3.get_yaxis().set_visible(False)
line4=ax4.vlines(x=bienc3, label="bien chuan", ymin=-1, ymax=1, color='g', linewidth=1, linestyle='-.')
ax4.get_xaxis().set_visible(False)
ax4.get_yaxis().set_visible(False)
fig.legend()
plt.title("studio_F2")

print(vert3)

bienc4=[23, 24, 39, 40, 44, 46, 66, 69, 77, 80, 97, 119]

fig, ax1=plt.subplots(figsize=(15, 5))
	# lệnh dưới cho phép trục y của ax2, ax3, ax4 đè lên ax1
ax2=ax1.twiny()
ax3=ax1.twiny()
ax3=ax1.twinx()
ax4=ax1.twiny()
ax4=ax1.twinx()
mask=np.zeros(len(ste4))
line1=ax1.plot(mask, linestyle='-', color='r', alpha=0)
line2=ax2.plot(data4, label="studio_M2", alpha=1)
ax2.get_xaxis().set_visible(False)
line3=ax3.vlines(x=vert4, label="bien tinh toan", ymin=-1, ymax=1, color='r', linewidth=1)
ax3.get_xaxis().set_visible(False)
ax3.get_yaxis().set_visible(False)
line4=ax4.vlines(x=bienc4, label="bien chuan", ymin=-1, ymax=1, color='g', linewidth=1, linestyle='-.')
ax4.get_xaxis().set_visible(False)
ax4.get_yaxis().set_visible(False)
fig.legend()
plt.title("studio_M2")

print(vert4)

