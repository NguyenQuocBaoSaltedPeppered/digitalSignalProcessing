# -*- coding: utf-8 -*-
"""123190059_NguyenQuocBao.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1k_ol9kbTljDOuPxll96k6tHdLio8_wD9
"""

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
#tính toán và vẽ đồ thị
import numpy as np
from numpy.fft import fft,ifft
import matplotlib.pyplot as plt
import math as m
#đọc file âm thanh
from IPython.display import Audio
#XLTH
import scipy
from scipy.io.wavfile import read,write
from scipy.signal import find_peaks

#-----------------------------------------------------------
#Thuật toán 1:
#Hàm tính STE:
#Tham số đầu vào: list đã được phân khung
#tính toán STE theo công thức đã học
#Giá trị trả về: một lits có số lượng phần tử là số khung và
#mỗi phần tử là một giá trị STE của khung tương ứng
def STE(array):
    temp=np.zeros(len(array))
    for i in range(len(array)):
        for j in range(len(array[i])):
            temp[i]=temp[i]+array[i][j]**2
        temp[i]=temp[i]/len(array[i])
    return temp

#-----------------------------------------------------------
#Hàm chuẩn hóa:
#Tham số đầu vào: list (mảng) 1 chiều (X)
#Tính toán theo công thức X[i]=(X[i]-min(X))/(max(X)-min(X))
#Giá trị trả về: list mới với các giá trị chạy từ 0 tới 1
def norm(array):
    minarr=np.min(array)
    maxarr=np.max(array)
    marr=maxarr-minarr
    for i in range(len(array)):
        array[i]=(array[i]-minarr)/marr
    return array

#-----------------------------------------------------------
#Hàm tìm các vạch phân đoạn:
#Tham số đầu vào: list là hàm kết hợp, moc là giá trị ngưỡng (threshold)
#Ở các vị trí hàm kết hợp trên băng qua ngưỡng, lưu lại chỉ số của list+1
#Đây chính là vạch phân đoạn cần tìm
def discriminate(array, moc):
    temp=[]
    x=0
    for i in range(len(array)-1):
        if(array[i]>moc>array[i+1] or array[i]<moc<array[i+1]):
            temp.append(i+1)
    return temp

#------------------------------------------------------------

fs1, data1=read('30FTN.wav')
fs2, data2=read('42FQT.wav')
fs3, data3=read('44MTT.wav')
fs4, data4=read('45MDV.wav')
data1=data1/abs(np.max(data1))
data2=data2/abs(np.max(data2))
data3=data3/abs(np.max(data3))
data4=data4/abs(np.max(data4))
#Ngưỡng
threshold=0.006

tframe=0.03
l1=len(data1)
l2=len(data2)
l3=len(data3)
l4=len(data4)
lframe1=tframe*fs1
lframe2=tframe*fs2
lframe3=tframe*fs3
lframe4=tframe*fs4
Framed_data1=np.array_split(data1, l1/lframe1)
Framed_data2=np.array_split(data2, l2/lframe2)
Framed_data3=np.array_split(data3, l3/lframe3)
Framed_data4=np.array_split(data4, l4/lframe4)


ste1=STE(Framed_data1)
ste1=norm(ste1)
ste2=STE(Framed_data2)
ste2=norm(ste2)
ste3=STE(Framed_data3)
ste3=norm(ste3)
ste4=STE(Framed_data4)
ste4=norm(ste4)
threshold=0.006
vert1=discriminate(ste1, threshold)
vert2=discriminate(ste2, threshold)
vert3=discriminate(ste3, threshold)
vert4=discriminate(ste4, threshold)

#N_FFT=2**11
#độ phân giải
#res=fs/N_FFT
#giới hạn peaks trong phổ biên độ ứng 0->1000 Hz ứng vs trục W
#npeaks=int(1000/res)
#k=np.arange(0, npeaks, 1)
#W=k*res
#F0_list:
#F0_list=np.zeros(len(ste))

bienc1=[20, 33, 59, 71, 115, 126, 157, 171, 199, 210]

fig, ax1=plt.subplots(figsize=(15, 5))
	# lệnh dưới cho phép trục y của ax2, ax3, ax4 đè lên ax1
ax2=ax1.twiny()
ax3=ax1.twiny()
ax3=ax1.twinx()
ax4=ax1.twiny()
ax4=ax1.twinx()
#mask=np.zeros(len(ste1))
line1=ax1.plot(ste1, linestyle='-', color='y', alpha=1, label="STE")
line2=ax2.plot(data1, label="data", alpha=0.5)
ax2.get_xaxis().set_visible(False)
line3=ax3.vlines(x=vert1, label="bien tinh toan", ymin=-1, ymax=1, color='r', linewidth=1)
ax3.get_xaxis().set_visible(False)
ax3.get_yaxis().set_visible(False)
line4=ax4.vlines(x=bienc1, label="bien chuan", ymin=-1, ymax=1, color='g', linewidth=1, linestyle='-.')
ax4.get_xaxis().set_visible(False)
ax4.get_yaxis().set_visible(False)
fig.legend()
plt.title("30FTN")

bienc2=[16, 33, 52, 71, 84, 98, 127, 146, 159, 174]

fig, ax1=plt.subplots(figsize=(15, 5))
	# lệnh dưới cho phép trục y của ax2, ax3, ax4 đè lên ax1
ax2=ax1.twiny()
ax3=ax1.twiny()
ax3=ax1.twinx()
ax4=ax1.twiny()
ax4=ax1.twinx()
#mask=np.zeros(len(ste1))
line1=ax1.plot(ste2, linestyle='-', color='y', alpha=1, label="STE")
line2=ax2.plot(data2, label="data", alpha=0.5)
ax2.get_xaxis().set_visible(False)
line3=ax3.vlines(x=vert2, label="bien tinh toan", ymin=-1, ymax=1, color='r', linewidth=1)
ax3.get_xaxis().set_visible(False)
ax3.get_yaxis().set_visible(False)
line4=ax4.vlines(x=bienc2, label="bien chuan", ymin=-1, ymax=1, color='g', linewidth=1, linestyle='-.')
ax4.get_xaxis().set_visible(False)
ax4.get_yaxis().set_visible(False)
fig.legend()
plt.title("42FQT")

bienc3=[31, 48, 87, 100, 157, 171, 209, 222, 268, 280]

fig, ax1=plt.subplots(figsize=(15, 5))
	# lệnh dưới cho phép trục y của ax2, ax3, ax4 đè lên ax1
ax2=ax1.twiny()
ax3=ax1.twiny()
ax3=ax1.twinx()
ax4=ax1.twiny()
ax4=ax1.twinx()
#mask=np.zeros(len(ste1))
line1=ax1.plot(ste3, linestyle='-', color='y', alpha=1, label="STE")
line2=ax2.plot(data3, label="data", alpha=0.5)
ax2.get_xaxis().set_visible(False)
line3=ax3.vlines(x=vert3, label="bien tinh toan", ymin=-1, ymax=1, color='r', linewidth=1)
ax3.get_xaxis().set_visible(False)
ax3.get_yaxis().set_visible(False)
line4=ax4.vlines(x=bienc3, label="bien chuan", ymin=-1, ymax=1, color='g', linewidth=1, linestyle='-.')
ax4.get_xaxis().set_visible(False)
ax4.get_yaxis().set_visible(False)
fig.legend()
plt.title("44MTT")

bienc4=[30, 45, 79, 94, 126, 138, 168, 184, 214, 227]

fig, ax1=plt.subplots(figsize=(15, 5))
	# lệnh dưới cho phép trục y của ax2, ax3, ax4 đè lên ax1
ax2=ax1.twiny()
ax3=ax1.twiny()
ax3=ax1.twinx()
ax4=ax1.twiny()
ax4=ax1.twinx()
#mask=np.zeros(len(ste1))
line1=ax1.plot(ste4, linestyle='-', color='y', alpha=1, label="STE")
line2=ax2.plot(data4, label="data", alpha=0.5)
ax2.get_xaxis().set_visible(False)
line3=ax3.vlines(x=vert4, label="bien tinh toan", ymin=-1, ymax=1, color='r', linewidth=1)
ax3.get_xaxis().set_visible(False)
ax3.get_yaxis().set_visible(False)
line4=ax4.vlines(x=bienc4, label="bien chuan", ymin=-1, ymax=1, color='g', linewidth=1, linestyle='-.')
ax4.get_xaxis().set_visible(False)
ax4.get_yaxis().set_visible(False)
fig.legend()
plt.title("45MDV")

#Thuật toán 2:

def Hamming(array, fs):
    N_FFT=2**11
    #Hamming
    magspec=array*np.hamming(len(array))
    #Magspec
    magspec=abs(fft(magspec, N_FFT))
    #Đổi sang dB
    magspec=20*np.log10(magspec[:magspec.size//2])
    return magspec

def F0(array, fs):
    N_FFT=2**11
    #độ phân giải
    resf=fs/N_FFT
    #tìm kiếm giới hạn từ 0->1000Hz
    npeaks=int(1000/resf)
    #tìm các peaks, tham số distance nhằm tránh các peaks quá gần nhau (hiệu 2 tần số dưới 110Hz)
    #Do frequency of human voice vẫn trên 100Hz (100Hz-120) kể cả khi đang nói thầm (nói rất nhỏ)
    peaks,_=find_peaks(array[:npeaks], distance=110/resf)
    #đổi các peaks từ số thành Hz
    peaks=peaks*resf
    #tìm vị trí các peaks đáng tin cậy
    delta1=0
    delta2=1
    delta3=2
    ktra=False
    #Kiểm tra nếu peaks đầu tiên dưới 70Hz (chắc chắn peaks ảo) loại
    if(peaks[0]<=70):
        peaks=peaks[1:]
    #Vào vòng lặp
    if(len(peaks)>3):
        #Vòng lặp delta1 (peaks1) đi từ 0->[:-2]
        for i in range(0, len(peaks)-2):
            #Vòng lặp delta2 (peaks2) đi từ delta1->[:-1]
            for j in range(i+1, len(peaks)-1):
                #Vòng lặp delta3 (peaks3) đi từ delta2->[:-2]
                #Điều kiện để các peaks được công nhận là đáng tin cậy
                if 0.7<abs(peaks[j]-peaks[i])/peaks[i]<1.3:
                    for k in range(j+1, len(peaks)):
                        if 0.7<2*abs(peaks[k]-peaks[j])/peaks[j]<1.3:
                            delta1=i
                            delta2=j
                            delta3=k
                            #Sau khi đã tìm ra, thoát khỏi vòng lặp
                            ktra=True
                            break
                    if(ktra):
                        break
            if(ktra):
                break
    if(ktra):
        A=(peaks[delta1]+(peaks[delta2]-peaks[delta1])+(peaks[delta3]-peaks[delta2]))/3
    #print(peaks)
    else:
        A=0
    return A

def Fft_F0(array1, ste, fs, array2):
    for i in range(0, len(ste)-1):
        if(ste[i]<0.006):
            continue
        else:
            fft_frame=Hamming(array1[i], fs)
            array2[i]=F0(fft_frame, fs)

#tính toán
#30FTN
F0_list1=np.zeros(len(ste1))
Fft_F0(Framed_data1, ste1, fs1, F0_list1)
#Vẽ đồ thị
x=[i/fs1 for i in range(len(data1))]
plt.figure(figsize=(20,2))
plt.plot(x, data1)

plt.figure(figsize=(20,2))
t=np.linspace(0, len(data1), len(F0_list1))
plt.plot(t, F0_list1, '.')
plt.ylim(70, 400)
plt.ylabel('Hz')
plt.xlabel('s')
plt.show()

#tính toán
#42FQT
F0_list2=np.zeros(len(ste2))
Fft_F0(Framed_data2, ste2, fs2, F0_list2)
#Vẽ đồ thị
x=[i/fs2 for i in range(len(data2))]
plt.figure(figsize=(20,2))
plt.plot(x, data2)

plt.figure(figsize=(20,2))
t=np.linspace(0, len(data2), len(F0_list2))
plt.plot(t, F0_list2, '.')
plt.ylim(70, 400)
plt.ylabel('Hz')
plt.xlabel('s')
plt.show()

#tính toán
#44MTT
F0_list3=np.zeros(len(ste3))
Fft_F0(Framed_data3, ste3, fs3, F0_list3)
#Vẽ đồ thị
x=[i/fs3 for i in range(len(data3))]
plt.figure(figsize=(20,2))
plt.plot(x, data3)

plt.figure(figsize=(20,2))
t=np.linspace(0, len(data3), len(F0_list3))
plt.plot(t, F0_list3, '.')
plt.ylim(70, 400)
plt.ylabel('Hz')
plt.xlabel('s')
plt.show()

#tính toán
#45MDV
F0_list4=np.zeros(len(ste4))
Fft_F0(Framed_data4, ste4, fs4, F0_list4)
#Vẽ đồ thị
x=[i/fs4 for i in range(len(data4))]
plt.figure(figsize=(20,2))
plt.plot(x, data4)

plt.figure(figsize=(20,2))
t=np.linspace(0, len(data4), len(F0_list4))
plt.plot(t, F0_list4, '.')
plt.ylim(70, 400)
plt.ylabel('Hz')
plt.xlabel('s')
plt.show()

def mean_std(array):
    temp=[]
    for i in range(len(array)):
        if(array[i]!=0):
            temp.append(array[i])
    print("Mean: ", np.mean(temp))
    print("Std: ", np.std(temp))
mean_std(F0_list1)
mean_std(F0_list2)
mean_std(F0_list3)
mean_std(F0_list4)

